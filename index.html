<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Energy Geostructures Map</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <link href="https://api.mapbox.com/mapbox-gl-js/v3.18.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.18.0/mapbox-gl.js"></script>

  <style>
    :root { --sidebar-w: 350px; }

    body { margin: 0; font-family: sans-serif; background: #f5f5f5; }

    .app {
      height: 100vh;
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
    }

    .sidebar {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.12);
      padding: 12px;
      overflow: auto;
    }

    .sidebar h1 { font-size: 16px; margin: 0 0 8px; }
    .sidebar .hint { font-size: 12px; color: #555; margin: 0 0 12px; line-height: 1.35; }

    .sidebar label { display: block; margin: 10px 0 4px; font-size: 12px; }

    .sidebar select {
      width: 100%;
      padding: 6px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fff;
    }

    .legend {
      margin-top: 10px;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 10px;
      background: #fafafa;
    }
    .legend-title {
      font-weight: 700;
      font-size: 12px;
      margin-bottom: 8px;
      letter-spacing: 0.3px;
      color: #222;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
      font-size: 12px;
      color: #222;
      user-select: none;
    }
    .legend-item input { transform: translateY(1px); }
    .legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.25);
      flex: 0 0 auto;
    }

    .sidebar .btnrow { display: flex; gap: 8px; margin-top: 12px; }
    .sidebar button {
      flex: 1;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fafafa;
      cursor: pointer;
    }
    .sidebar button:hover { background: #f0f0f0; }

    .stats {
      margin-top: 12px;
      font-size: 12px;
      color: #333;
      padding: 10px;
      border: 1px dashed #ddd;
      border-radius: 10px;
      background: #fcfcfc;
    }

    .map-panel {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.12);
      overflow: hidden;
      position: relative;
    }

    #map { width: 100%; height: 100%; }

    .popup-content {
      max-height: 240px;
      overflow-y: auto;
      overflow-x: hidden;
      font-size: 12px;
    }

    .mapboxgl-ctrl-top-right { top: 10px; right: 10px; }

    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      :root { --sidebar-w: 100%; }
    }
  </style>
</head>

<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Energy Geostructures</h1>
      <p class="hint">Tick types to show/hide them. Filter by country. Click a point to see attributes.</p>

      <label for="countrySelect">Filter by Country</label>
      <select id="countrySelect">
        <option value="__all__">All</option>
      </select>

      <div class="legend">
        <div class="legend-title">TYPES</div>
        <div id="typeLegend"></div>
      </div>

      <div class="btnrow">
        <button id="resetBtn" type="button">Reset filters</button>
        <button id="fitAllBtn" type="button">Fit all points</button>
      </div>

      <div class="stats" id="statsBox">Loading dataâ€¦</div>
    </aside>

    <main class="map-panel">
      <div id="map"></div>
    </main>
  </div>

  <script>
    mapboxgl.accessToken =
      "pk.eyJ1IjoicGphZmFyeSIsImEiOiJjbWttMnB1cWgwYm9yM2VvcjBsaDVjZjZ6In0.4hnFagy7O71f_AJTMS1guQ";

    let geojson;
    let allBounds;
    let layerReady = false;

    // --- Fields in your GeoJSON (must match exactly) ---
    const FIELD_TYPE = "Type";
    const FIELD_COUNTRY = "Installation type - Country";
    const GEOJSON_FILE = "./data.geojson";

    const countrySelect = document.getElementById("countrySelect");
    const resetBtn = document.getElementById("resetBtn");
    const fitAllBtn = document.getElementById("fitAllBtn");
    const statsBox = document.getElementById("statsBox");
    const typeLegendEl = document.getElementById("typeLegend");

    // --- Your fixed Type categories + colours ---
    const TYPE_CONFIG = [
      { label: "Energy Barrettes",         color: "#6A1B9A" },
      { label: "Energy Anchors",           color: "#C62828" },
      { label: "Energy Slabs",             color: "#2E7D32" },
      { label: "Energy Sheet Pile Walls",  color: "#8E24AA" },
      { label: "Geothermal Pavements",     color: "#EF6C00" },
      { label: "Energy Piles",             color: "#1565C0" },
      { label: "Energy Tunnels",           color: "#00838F" },
      { label: "Energy Retaining Walls",   color: "#6D4C41" }
    ];

    const TYPE_SET = new Set(TYPE_CONFIG.map(t => t.label));

    function norm(s) {
      return String(s ?? "").trim();
    }

    // Normalise common variants from your data into the fixed labels above
    function normaliseType(raw) {
      const v = norm(raw);
      if (!v) return v;

      const low = v.toLowerCase().replace(/\s+/g, " ").trim();

      // direct exact match
      for (const t of TYPE_CONFIG) {
        if (low === t.label.toLowerCase()) return t.label;
      }

      // common variants -> standard
      if (low === "energy slab" || low === "energy slabs") return "Energy Slabs";
      if (low === "energy sheet pile wall" || low === "energy sheet pile walls") return "Energy Sheet Pile Walls";
      if (low === "energy sheet-pile walls" || low === "energy sheet-pile wall") return "Energy Sheet Pile Walls";
      if (low === "geothermal pavement" || low === "geothermal pavements") return "Geothermal Pavements";
      if (low === "energy pile" || low === "energy piles") return "Energy Piles";
      if (low === "energy tunnel" || low === "energy tunnels") return "Energy Tunnels";
      if (low === "energy barrette" || low === "energy barrettes") return "Energy Barrettes";
      if (low === "energy anchor" || low === "energy anchors") return "Energy Anchors";
      if (low === "energy retaining wall" || low === "energy retaining walls") return "Energy Retaining Walls";

      // If data has something unexpected, keep it (it just won't be in the fixed legend)
      return v;
    }

    function buildTypeLegend() {
      typeLegendEl.innerHTML = "";

      for (const t of TYPE_CONFIG) {
        const row = document.createElement("label");
        row.className = "legend-item";
        row.innerHTML = `
          <input type="checkbox" class="typeCheck" value="${t.label}" checked />
          <span class="legend-swatch" style="background:${t.color}"></span>
          <span>${t.label}</span>
        `;
        typeLegendEl.appendChild(row);
      }
    }

    function getSelectedTypes() {
      const checks = Array.from(document.querySelectorAll(".typeCheck"));
      return checks.filter(c => c.checked).map(c => c.value);
    }

    const map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/streets-v12",
      center: [0, 20],
      zoom: 1.2,
      projection: "mercator"
    });

    map.on("style.load", () => {
      map.setProjection("mercator");
    });

    map.addControl(new mapboxgl.NavigationControl({ showCompass: false }), "top-right");

    // Flat 2D, no rotation
    map.dragRotate.disable();
    map.touchZoomRotate.disableRotation();
    map.keyboard.disableRotation();
    map.setPitch(0);
    map.setBearing(0);
    map.setMaxPitch(0);

    // Zoom allowed
    map.scrollZoom.enable();
    map.doubleClickZoom.enable();
    map.keyboard.enable();
    map.touchZoomRotate.enable(); // pinch zoom OK, rotation stays disabled

    function computeBounds(features) {
      const b = new mapboxgl.LngLatBounds();
      for (const f of features) {
        if (f?.geometry?.type === "Point") b.extend(f.geometry.coordinates);
      }
      return b;
    }

    function currentFilteredFeatures() {
      if (!geojson?.features) return [];
      const c = countrySelect.value;
      const selectedTypes = new Set(getSelectedTypes());

      return geojson.features.filter(f => {
        if (f?.geometry?.type !== "Point") return false;
        const p = f.properties || {};

        const okCountry = (c === "__all__") || (norm(p[FIELD_COUNTRY]) === norm(c));
        const tClean = norm(p.Type_clean);
        const okType = selectedTypes.size === 0 ? false : selectedTypes.has(tClean);

        return okCountry && okType;
      });
    }

    function updateStats(filteredCount, totalCount) {
      const c = countrySelect.value === "__all__" ? "All" : countrySelect.value;
      const selectedTypes = getSelectedTypes();
      statsBox.innerHTML = `
        <div><b>Total points:</b> ${totalCount}</div>
        <div><b>Visible points:</b> ${filteredCount}</div>
        <div><b>Country:</b> ${c}</div>
        <div><b>Selected types:</b> ${selectedTypes.length} / ${TYPE_CONFIG.length}</div>
      `;
    }

    function applyFilters({ fitToFiltered = false } = {}) {
      if (!layerReady) return;

      const selectedTypes = getSelectedTypes();
      const cVal = countrySelect.value;

      // If no types ticked, show nothing
      const typeFilter = (selectedTypes.length === 0)
        ? ["==", ["get", "Type_clean"], "__none__"]
        : ["in", ["get", "Type_clean"], ["literal", selectedTypes]];

      const filters = ["all", typeFilter];

      if (cVal !== "__all__") {
        filters.push(["==", ["to-string", ["get", FIELD_COUNTRY]], cVal]);
      }

      map.setFilter("points-layer", filters);

      const filtered = currentFilteredFeatures();
      updateStats(filtered.length, geojson?.features?.length || 0);

      if (fitToFiltered && filtered.length > 0) {
        const b = computeBounds(filtered);
        if (!b.isEmpty()) map.fitBounds(b, { padding: 60, maxZoom: 6 });
      }
    }

    function fitAllPoints() {
      if (allBounds && !allBounds.isEmpty()) {
        map.fitBounds(allBounds, { padding: 50, maxZoom: 4 });
      }
    }

    // Build the legend UI now
    buildTypeLegend();

    map.on("load", async () => {
      const res = await fetch(GEOJSON_FILE);
      geojson = await res.json();

      // Normalise Type into a new property: Type_clean
      const unknownTypes = new Set();
      for (const f of geojson.features) {
        const p = f.properties || {};
        const cleaned = normaliseType(p[FIELD_TYPE]);
        p.Type_clean = cleaned;

        // Track types not in your fixed list (optional debug)
        if (cleaned && !TYPE_SET.has(cleaned)) unknownTypes.add(cleaned);
        f.properties = p;
      }
      if (unknownTypes.size > 0) {
        console.warn("Types found in data not in the fixed legend list:", [...unknownTypes]);
      }

      // Populate Country dropdown from data
      const countries = new Set();
      geojson.features.forEach(f => {
        const p = f.properties || {};
        const v = norm(p[FIELD_COUNTRY]);
        if (v) countries.add(v);
      });
      [...countries].sort().forEach(v => {
        const o = document.createElement("option");
        o.value = v; o.textContent = v;
        countrySelect.appendChild(o);
      });

      // Add source
      map.addSource("points", { type: "geojson", data: geojson });

      // Build icon-color expression based on Type_clean
      const colorMatch = ["match", ["get", "Type_clean"]];
      for (const t of TYPE_CONFIG) {
        colorMatch.push(t.label, t.color);
      }
      colorMatch.push("#666666"); // fallback colour

      // Add symbol layer using built-in marker icon (colourable)
      map.addLayer({
        id: "points-layer",
        type: "symbol",
        source: "points",
        layout: {
          "icon-image": "marker-15",
          "icon-size": 1.1,
          "icon-allow-overlap": true
        },
        paint: {
          "icon-color": colorMatch,
          "icon-halo-color": "#ffffff",
          "icon-halo-width": 1
        }
      });

      layerReady = true;

      // Cache bounds and fit initial view
      allBounds = computeBounds(geojson.features);
      fitAllPoints();

      // Initial stats + filters
      updateStats(geojson.features.length, geojson.features.length);
      applyFilters({ fitToFiltered: false });

      // Popup
      map.on("click", "points-layer", e => {
        const p = e.features[0].properties || {};
        const html = `
          <div class="popup-content">
            ${Object.entries(p)
              .slice(5, 67)
              .map(([k, v]) => `<div><b>${k}</b>: ${v}</div>`)
              .join("")}
          </div>`;
        new mapboxgl.Popup()
          .setLngLat(e.lngLat)
          .setHTML(html)
          .addTo(map);
      });

      map.on("mouseenter", "points-layer", () => { map.getCanvas().style.cursor = "pointer"; });
      map.on("mouseleave", "points-layer", () => { map.getCanvas().style.cursor = ""; });

      // Events
      countrySelect.addEventListener("change", () => applyFilters({ fitToFiltered: true }));

      // When any checkbox changes
      document.querySelectorAll(".typeCheck").forEach(cb => {
        cb.addEventListener("change", () => applyFilters({ fitToFiltered: false }));
      });

      resetBtn.addEventListener("click", () => {
        countrySelect.value = "__all__";
        document.querySelectorAll(".typeCheck").forEach(cb => cb.checked = true);
        applyFilters({ fitToFiltered: false });
        fitAllPoints();
      });

      fitAllBtn.addEventListener("click", () => fitAllPoints());
    });
  </script>
</body>
</html>
